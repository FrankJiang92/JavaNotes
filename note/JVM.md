### JVM

---

#### JVM生命周期

* 每一个应用程序对应一个JVM
* 一个应用程序从main函数开始，会启动一个线程执行任务
* JVM有两种线程: 守护线程和非守护线程
* 应用程序默认为非守护线程，可以通过setDemon将自己的线程设置为守护线程
* 非守护线程执行完毕，虚拟机才会退出


#### JVM的执行过程

* JVM内部结构

![JVM结构](res/jvm.png)

* 类加载：`classloader`

负责从文件系统或网络中加载Class信息，加载的信息存放于一块成为方法去的内存空间。除了类信息以外，方法区可能还会存放运行时常量池信息，包括字符串字面量和数字常量。

* 运行时数据区：`runtime data area`
	* 读取class文件的二进制字节流到内存中
	* 每一个jvm实例都有一个方法区和堆区
	* 方法区`method area`
		* 所有线程共享
		* 解析完的class文件类型（类，接口，数组）信息
		* 除了类信息外，还会存放运行时常量池信息，包括字符串字面量和数字常量
	* 堆区`heap`
		* 所有线程共享，涉及到多线程访问 
		* 创建对象，数组
		* 几乎所有的Java对象实例都存放与Java堆中
		* 根据垃圾回收机制不同，Java堆有不同的结构
		* 最常见的一种结构是将Java堆分为新生代和老年代
	* 直接内存
		* Java的NIO库允许Java程序使用直接内存，直接内存在Java堆外，直接向系统申请的内存空间
		* 访问直接内存的速度会由于Java堆
	* Java栈`java stack`
		* 对应每一个线程，线程私有
		* 一个线程创建时会创建Java栈
		* Java栈中保存着帧信息，保存着局部变量、方法参数，同时和Java方法的调用和返回密切相关
		* 线程执行的基本行为是函数调用，每次函数调用的数据都是通过Java栈传递的
	* PC寄存器`program counter register`
		* 对应每一个线程，线程私有
		* 记录当前程序执行的位置
	* 本地方法栈
		* 用于本地方法（C）的调用

* 执行引擎：`execution engine`
	* 负责执行虚拟机的字节码

* 垃圾回收系统
	* 可以对方法区、Java堆和直接内存进行回收

#### 运行时数据区

* 方法区
	* 类的信息
		* 类，接口，数组？
		* 类的全名
		* 修饰符
		* 父接口，父类
		* 常量值
		* 字段
		* 方法
		* 静态变量
	* 也存在垃圾回收
* 堆区
	* 对象的存储方式
	* 数组？
	* 与对象创建与GC有关系
	* 对象锁

* Java栈
	* 每一个线程都有一个Java栈
	* 每一个方法从调用到执行，对应着一个栈帧在VM里面从入栈到出栈的过程
	* 栈帧从Java栈中弹出有两种方式
		* 正常的函数返回，使用return指令
		* 抛出异常
	* Java栈帧
		* 局部变量区：存储下标
		* 操作数栈
		* 帧数据区
	* 每次函数调用都会产生对应的栈帧，会占用一定的栈空间，如果请求的栈深度大于最大可用栈深度时，会抛出StackOverflowError栈溢出错误
	* 栈上分配
		* 对于线程私有的对象（不可能被其他线程访问的对象）可以把它们分配在栈上，而不是分配在堆上
		* 分配在栈上的好处是函数调用结束后自行销毁，不需要垃圾回收期的介入，提高系统的性能
		* 栈上分配的技术基础是进行逃逸分析。逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体

#### 类加载器

* 装载
* 链接
* 初始化
* `Class.forName()`: 保证对驱动程序进行初始化
* `ClassLoader`
	* 分类
		* `BootStrap ClassLoader`:加载Java核心类库jre/lib
		* `Extension ClassLoader`:读取Java扩展类库jre/lib/ext
		* `App ClassLoader`:读取classpath指定的所有jar包和目录的类文件
		* `Custom ClassLoader`:用户自定义的，用来读取指定类文件
	* 双亲委派
		* 如何保证安全性
	* load流程
		![classloader](res/classloader.png)
	* 定义类装载器：能装载某个类的装载器成为该类的定义类装载器
	* 初始类装载器：能够成功返回某类的class引用的装载器
	* 包装模式
* 运行时包
	* 避免用户冒充核心类库
* class文件
	* 开头字符：cafe babe
	* 主版本号和次版本号
	* 常量池
	* this class
	* super class

#### 执行引擎

* 指令集
	* 精简指令集
	* 操作码
	* 操作数
* 执行技术
	* 编译技术
* 线程相关
	* Java的优先级，不靠谱
* **Java内存模型**
	* JMM
	* 主存与工作内存
	* 多线程并发问题
* Java本地调用(JNI)

#### Java垃圾回收机制

* 检测
	* 根路径
	* 如何检测到对象可以被回收
		* 引用计数：无法解决循环引用和性能等问题，暂不采用
		* 标记清除：遍历所有，最后清除
		* 标记压缩；
		* 拷贝（copy）
		* 分代（generational collection）
		* 并发收集
		* 并行收集
		* 自适应收集
* 回收
* JVM内存管理模式
	* 分代管理
	* 可触及性
		* 强/软/弱/虚可触及
		* 对应引用（reference）：强/软/弱/虚引用
		* 软引用：缓存机制
		* 弱引用：WeakHashMap
		* *编程时如何使用？*
* Java中如何使用GC（不推荐使用）

##### 垃圾回收算法

* 引用计数法 `Reference Counting`
	* 实现：对于一个对象A，只要有任意一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要A的引用计算器为0，则对象A就不可能再被使用。
	* 存在问题
		* 无法处理循环应用的问题
		* 引用计数器要求在每次因引用产生和消除时，需要伴随加法和减法操作，对系统性能有影响
	* 名词解释
		* 可达对象：通过根对象进行引用搜索，最终可以达到的对象
		* 不可达对象：通过根对象进行引用搜索，最终没有被引用到的对象

* 标记清除法 `Mark Sweep`
	* 将垃圾回收分为两个阶段：标记阶段和清除阶段
	* 标记阶段
		* 首先通过根节点，标记所有从根节点开始的可达对象
		* 然后未被标记的就是未被引用的垃圾对象
	* 清除阶段
		* 清除所有的未被标记的对象
	* 存在问题
		* 回收后的空间是不连续的；不连续的内存空间工作效率低于连续的空间
		* 最大的问题是造成空间碎片

* 复制算法（`Copying`）
	* 实现：将原有内存空间分为两块，每次只使用其中一块，垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后清除正在使用的内存块中的对象，交换两个内存的角色，完成垃圾回收
	* 其高效性建立在存活对象少、垃圾对象多的前提下；比较适用于新生代
	* 名词解释
		* 新生代：存放年轻对象的堆空间
		* 老年代：存放老年对象的堆空间

* 标记压缩法（`Mark-Compact`）
	* 是一种老年代的回收算法，在标记清除算法的基础上做了优化。
	* 实现：从根节点出发，标记所有的可达对象；将所有的存活对象压缩到内存的一端；之后清理边界外的所有空间
	* 避免了碎片的产生，又不需要两块相同的内存空间，性价比比较高
	* 等同于标记清除算法执行完成后，再进行一次内存碎片整理，也可以称为标记清除压缩算法

* 分代算法
	* 将内存区间根据对象特点分成几块，根据每块内存区间的特点，使用不同的回收算法，以提高回收的效率
	* 实现：JVM会将新建对象放入新生代的内存区域，新生代的新建对象90%会被很快回收，所以对新生代比较适合使用复制算法；当一个对象经过几次回收后依然存活，对象会被放入称为老年代的内存空间，老年代所有对象都是经过几次垃圾回收后依然得以存活的，如果使用复制算法需要复制大量对象，所以根据分代的思想，对老年代的回收使用标记压缩或标记清除算法，以提高垃圾回收效率。
	* 为了支持高频率的新生代回收，使用卡表（`Card Table`）的数据结构
	* 卡表：
		* 比特位集合，每个比特位表示老年代某一区域中所有对象是否持有新生代对象的引用，这样新生代GC时就不需要花大量时间扫描所有的老年代对象，来确定每个对象的引用关系
		* 可以先扫描卡表，只有当卡表的标记位为1时，才需要扫描该区域的老年代对象，而卡表位为0的所在区域的老年代，一定不含有新生代对象引用，所以不需要扫描该区域。

* 分区算法
	* 按照堆空间划分为连续的不同小区域，每个小区域独立使用，独立回收
	* 优点在于可以控制一次回收多少个小区间
	* 堆空间越大，GC的时间越长，产生停顿也越长；分区回收，可以每次合理的回收若干个小区间，而不是整个堆空间，减少一次GC的停顿

##### 判断可触及性

* 强引用
	* 可触及，不可回收
	* 特点
		* 可以直接访问目标对象
		* 所指向的对象在任何时候都不会被系统回收，宁愿抛出OOM异常
		* 可能导致内存泄漏
	* 注意：
		* 在某个方法中，`StringBuffer str = new StringBuffer("Hello");`
		* str为局部变量，定义在局部变量表，在栈中定义
		* StringBuffer的实例对象，在堆空间中定义
		* str指向StringBuffer的堆空间地址
		* 为强引用

* 软引用——可被回收的引用
	* 一个对象只持有软引用，当堆空间不足时，该对象会被回收
	* 特点
		* GC未必会回收软引用对象
		* 当内存资源紧张时，软引用对象会被回收
		* 软引用对象不会引起内存溢出
	* 使用
	``` java
	// 定义StringBuffer对象的强引用
	StringBuffer sb = new StringBuffer("hello world");
	// 通过强引用sb，建立软引用
	SoftReference<StringBuffer> sbSoftRef = new SoftReference<StringBuffer>(sb);
	// 去除强引用
	sb = null;
	```

* 弱引用——发现即回收
	* 比软引用较弱的引用
	* 在GC时，只要发现弱引用，不管系统堆空间如何，都会将对象进行回收
	* 使用
	``` java
	StringBuffer sb = new StringBuffer("Hello world");
	WeakReference<StringBuffer> sbWeakRef = new WeakReference<StringBuffer>(sb);
	sb = null;
	```
	* 注意：软引用和弱引用可以适合保存可有可无的缓存数据；系统资源不足时，可以进行回收而不会导致内存溢出；系统资源充足时，缓存数据又可以存在很长时间，加速系统

* 虚引用——对象回收跟踪
	* 所有引用类型中最弱的一个
	* 一个持有虚引用的对象，和没有引用是一样的
	* 随时可以被垃圾回收器回收，且通过虚引用的get方法取得强引用时，总是会失败
	* 虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程
	* 当垃圾回收器准备回收一个对象时，如果发现他还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况
	* 使用
	``` java
	StringBuffer sb = new StringBuffer("Hello world");
	PhantomReference<StringBuffer> sbPhantomRef = new PhantomReference<StringBuffer>(sb);
	sb = null;
	```
##### 垃圾回收时的停顿现象

* Stop-The-World
* 为了让垃圾回收器正常且高效的执行，大部分情况下，系统进入到一个停顿的状态
* 停顿的目的是终止所有应用程序线程的执行，只有这样，系统才不会有新的垃圾产生，同时停顿保证了系统状态在某一个瞬间的一致性，也有益于垃圾回收器更好的标记垃圾对象

##### 垃圾回收器

* 串行回收器
	* 特点
		* 使用单线程进行垃圾回收的回收器，每次回收时，串行回收器只有一个工作线程
		* 独占式的垃圾回收
	* 新生代串行回收器
		* 使用复制算法
		* 实现简单，逻辑处理比较高效，且没有线程切换的开销
	* 老年代串行回收器
		* 使用标记压缩算法
		* 一旦启动，会导致应用程序卡顿

* 并行回收器
	* 特点
		* 多个线程同时进行垃圾回收
	* 新生代ParNew回收器
		* 工作在新生代
		* 简单的将串行回收器多线程化
		* 回收策略、算法和参数都与新生代串行回收器一样
		* 使用复制算法
	* 新生代ParallelGC回收器
		* 使用复制算法的回收器
		* 多线程、独占式的收集器
		* 更加注重系统的吞吐量，可以通过设置最大垃圾收集停顿时间和设置吞吐量的大小
		* 还可以使用自适应GC策略，自动调整新生代大小、edenhe survivior比例、晋升老年代的年龄等参数
	* 老年代ParallelOldGC回收器
		* 多线程并发收集器
		* 关注吞吐量，与Parallel回收器类是
		* 应用与老年代的回收器，并且与新生代ParallelGC回收器搭配使用
		* 使用标记压缩算法

#### Java性能准则

#### JVM的同步问题

#### JVM的对象创建
* 创建方式
	* new方式
	* 反射方式
	* clone方式
	* 序列化、反序列化
* 创建过程

#### JVM沙箱
* classloader 双亲委派
* 运行时包
* 文件检验器
* 安全管理器，保护域

#### JVM开源虚拟机
* openjdk_hospot
* javax_ibm

##### 参考

* [JVM内存管理机制](http://blog.csdn.net/lengyuhong/article/details/5953544)
* [JVM类加载那些事](http://www.jianshu.com/p/2133558b4735)
* [如何利用 JConsole观察分析Java程序的运行，进行排错调优](http://jiajun.iteye.com/blog/810150)
* [如何使用JVisualVM进行性能分析](http://jiajun.iteye.com/blog/1180230)
* [宋秉华JAVA虚拟机的实现机制讲座](http://v.youku.com/v_show/id_XMTUxMDM1OTcy.html?beta&)
* [JVM 的 工作原理，层次结构 以及 GC工作原理](https://segmentfault.com/a/1190000002579346)
* [JVM 栈帧](http://www.360doc.com/content/14/0925/13/1073512_412236522.shtml)
* [深入理解Java运行时数据区](http://blog.csdn.net/zhangjg_blog/article/details/24271275)
* [类加载器总结](http://blog.csdn.net/gjanyanlig/article/details/6818655)
* [Java GC基本算法](http://www.blogjava.net/showsun/archive/2011/07/21/354745.html)
* [java安全沙箱之ClassLoader双亲委派机制](http://my.oschina.net/xionghui/blog/499725#OSC_h1_3)
* [Java之深入JVM(6) - 字节码执行引擎(转)](http://www.cnblogs.com/royi123/p/3569511.html)